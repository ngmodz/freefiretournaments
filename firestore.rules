rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // This block replaces the three previous /users/{userId} blocks
    match /users/{userId} {
      // Allow anyone to read user profiles (for tournament host display etc.)
      allow read: if true;

      // Allow creation of a user document
      allow create: if request.auth != null && 
        request.auth.uid == userId;

      // SECURE UPDATE LOGIC
      allow update: if request.auth != null && (
        // Case 1: Users can update their OWN profile.
        (request.auth.uid == userId &&
         // They are NOT allowed to change their host status.
         (request.resource.data.isHost == resource.data.isHost) &&
         // Allow wallet updates for various scenarios
         (
           // Withdrawal: earnings are being reduced and credits are unchanged
           (
            'wallet' in request.resource.data && 'wallet' in resource.data &&
            request.resource.data.wallet.earnings < resource.data.wallet.earnings &&
            request.resource.data.wallet.get('credits', 0) == resource.data.wallet.get('credits', 0)
           ) ||
           // Tournament join or prize pool funding: tournamentCredits can be reduced
           (
            'wallet' in request.resource.data && 'wallet' in resource.data &&
            request.resource.data.wallet.get('tournamentCredits', 0) < resource.data.wallet.get('tournamentCredits', 0) &&
            request.resource.data.wallet.get('earnings', 0) == resource.data.wallet.get('earnings', 0)
           ) ||
           // Host prize pool funding: hostCredits can be reduced
           (
            'wallet' in request.resource.data && 'wallet' in resource.data &&
            request.resource.data.wallet.get('hostCredits', 0) < resource.data.wallet.get('hostCredits', 0) &&
            request.resource.data.wallet.get('earnings', 0) == resource.data.wallet.get('earnings', 0)
           ) ||
           // Or if wallet is unchanged.
           (request.resource.data.wallet == resource.data.wallet) ||
            // Or if wallet didn't exist and is not being added.
           (!('wallet' in request.resource.data) && !('wallet' in resource.data))
         )
        ) ||
        
        // Case 2: Admin can ONLY update isHost field (for host approval)
        (request.auth.token.admin == true &&
         request.resource.data.diff(resource.data).affectedKeys().hasAll(['isHost']) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isHost', 'updated_at']))
      );

      // Allow users to delete their own profiles
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Tournament-related rules
    match /tournaments/{tournamentId} {
      allow read: if true; // Anyone can view tournaments
      
      // Only verified hosts can create tournaments
      allow create: if request.auth != null && 
                    exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                    get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isHost == true;
      
      // Allow updates for tournament hosts, admins, and for users joining tournaments.
      // Notification-related fields should only be updatable by an admin.
      allow update: if request.auth != null && (
        // Admin users can update anything
        request.auth.token.admin == true ||
        
        // Rules for tournament hosts, conditioned by being the actual host
        (resource.data.host_id == request.auth.uid && (
          // 1. Host can cancel a tournament if it's active or ongoing
          (
            ['active', 'ongoing'].includes(resource.data.status) &&
            request.resource.data.status == 'cancelled' &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'cancelled_at', 'ttl'])
          ) ||

          // 2. Host can manage a tournament's lifecycle (start/end)
          (
            request.resource.data.status in ['ongoing', 'ended'] &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'started_at', 'ended_at', 'ttl'])
          ) ||

          // 3. Host can update room details, but ONLY before it starts
          (
            resource.data.status == 'active' &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['room_id', 'room_password'])
          ) ||

          // 4. Host can distribute prizes, but ONLY after it has ended
          (
            resource.data.status == 'ended' &&
            request.resource.data.diff(resource.data).affectedKeys().hasAll(['winners', 'currentPrizePool']) &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['winners', 'currentPrizePool', 'status', 'completed_at'])
          )
        )) ||
        
        // Special rule for users joining tournaments
        (
          // Only allow updates to participants, participantUids, filled_spots and currentPrizePool fields
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['participants', 'participantUids', 'filled_spots', 'currentPrizePool']) &&
          
          // Ensure filled_spots is only incremented by 1
          request.resource.data.filled_spots == resource.data.filled_spots + 1 &&
          
          // Ensure currentPrizePool is incremented by the entry fee amount
          request.resource.data.currentPrizePool == (resource.data.currentPrizePool == null ? 0 : resource.data.currentPrizePool) + resource.data.entry_fee &&
          
          // Ensure the user wasn't already in the participantUids list
          (resource.data.participantUids == null || !(request.auth.uid in resource.data.participantUids)) &&
          
          // Check that the tournament isn't full
          resource.data.filled_spots < resource.data.max_players &&
          
          // Check that tournament is in 'active' status
          resource.data.status == 'active' &&
          
          // Ensure the joining user is authenticated
          request.auth.uid != null
        )
      );
      
      allow delete: if request.auth != null && 
                    (request.auth.token.admin == true || 
                     resource.data.host_id == request.auth.uid ||
                     // Allow system deletion for expired tournaments
                     (resource.data.ttl != null && resource.data.ttl <= request.time));
    }
    
    // Important: Allow users to list tournaments they host
    match /tournaments {
      allow list: if request.auth != null && 
                  request.query.limit <= 100 && 
                  request.query.where.size() > 0 && 
                  request.query.where[0][0] == 'host_id' && 
                  request.query.where[0][1] == '==' && 
                  request.query.where[0][2] == request.auth.uid;
    }
    
    // Tournament drafts
    match /tournament_drafts/{draftId} {
      allow read: if request.auth != null && resource.data.host_id == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.host_id == request.auth.uid;
      allow update: if request.auth != null && 
                    (resource.data.host_id == request.auth.uid && 
                     request.resource.data.host_id == request.auth.uid);
      allow delete: if request.auth != null && resource.data.host_id == request.auth.uid;
    }
    
    // Allow users to create verification requests for IGN/UID
    match /verification_requests/{requestId} {
      allow read: if request.auth != null && 
                   (resource.data.userId == request.auth.uid ||
                   request.auth.token.admin == true);
      allow create: if request.auth != null && 
                     request.resource.data.userId == request.auth.uid;
      allow update, delete: if request.auth != null && request.auth.token.admin == true;
    }
    
    // Tournament credit and host credit transactions
    match /creditTransactions/{transactionId} {
      // Allow reading any credit transaction if the user ID matches the authenticated user
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid
      );
      
      // Allow creating credit transactions if userID matches authenticated user
      // Re-enabling 'tournament_win' transactions but with an added security check.
      allow create: if request.auth != null && (
        request.resource.data.userId == request.auth.uid ||
        // Allow tournament host to create a 'tournament_win' transaction for a winner.
        // This is now more secure. We verify the requester is the host of the tournament
        // AND that the tournament has ended.
        (
          request.resource.data.type == 'tournament_win' &&
          get(/databases/$(database)/documents/tournaments/$(request.resource.data.transactionDetails.tournamentId)).data.host_id == request.auth.uid &&
          get(/databases/$(database)/documents/tournaments/$(request.resource.data.transactionDetails.tournamentId)).data.status == 'ended'
        )
      );
      
      // No updates or deletions for credit transactions
      allow update: if false;
      allow delete: if false;
    }
    
    // Important: Allow users to list their own credit transactions
    match /creditTransactions {
      allow list: if request.auth != null && request.query.limit <= 100 && 
                  request.query.where.size() > 0 && 
                  request.query.where[0][0] == 'userId' && 
                  request.query.where[0][1] == '==' && 
                  request.query.where[0][2] == request.auth.uid;
    }
    
    // Rules for withdrawal requests
    match /withdrawalRequests/{requestId} {
      // Allow user to create a withdrawal request for themselves
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;

      // Allow user to read their own withdrawal requests
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid || 
        request.auth.token.admin == true
      );
      
      // Only admins can update the status (e.g., to 'completed') or delete
      allow update, delete: if request.auth != null && request.auth.token.admin == true;
    }
    
    // Admins can list all withdrawal requests. Users can only list their own.
    match /withdrawalRequests {
      // Allow admins to list all withdrawal requests without constraints
      allow list: if request.auth != null && (
          request.auth.token.admin == true || 
          (
            request.query.limit <= 100 && 
            request.query.where.size() > 0 && 
            request.query.where[0][0] == 'userId' && 
            request.query.where[0][1] == '==' && 
            request.query.where[0][2] == request.auth.uid
          )
        );
    }

    // Legacy wallet and transaction rules - keeping for backward compatibility
    // Wallet rules - allow users to access only their own wallet
    match /wallets/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if request.auth != null && request.auth.uid == userId; // Allow wallet deletion if owned by user
    }
    
    // Simplified transaction rules
    match /transactions/{transactionId} {
      // Allow reading any transaction if the user ID matches the authenticated user
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid
      );
      
      // Allow creating transactions if userID matches authenticated user
      allow create: if request.auth != null && (
        request.resource.data.userId == request.auth.uid
      );
      
      // No updates, but allow deletions for own transactions
      allow update: if false;
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Important: Allow users to list their own transactions
    match /transactions {
      allow list: if request.auth != null && request.query.limit <= 100 && 
                  request.query.where.size() > 0 && 
                  request.query.where[0][0] == 'userId' && 
                  request.query.where[0][1] == '==' && 
                  request.query.where[0][2] == request.auth.uid;
    }
    
    // Explicitly deny access to test_connection collection
    match /test_connection/{document=**} {
      allow read, write: if false;
    }
    
    // Host Applications collection - FIXED VERSION
    match /hostApplications/{applicationId} {
      // Allow any authenticated user to create an application
      allow create: if request.auth != null;
      
      // Allow users to read their own applications OR admins to read all
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        request.auth.token.admin == true
      );
      
      // Only admins can update applications (for approval/rejection)
      allow update: if request.auth != null && request.auth.token.admin == true;
      
      // Prevent deletion for record-keeping
      allow delete: if false;
    }

    // Consolidated and corrected rules for support submissions
    match /supportSubmissions/{submissionId} {
      // Allow any user to create a submission.
      // If a UID is provided, it must match the authenticated user.
      allow create: if request.resource.data.uid == null ||
                      (request.auth != null && request.resource.data.uid == request.auth.uid);

      // Allow only admins to read or delete submissions.
      allow read, delete: if request.auth != null && request.auth.token.admin == true;

      // Prevent updates to submissions for data integrity.
      allow update: if false;
    }

    // Admins can list all support submissions.
    match /supportSubmissions {
      allow list: if request.auth != null && request.auth.token.admin == true;
    }

    // Admins can list all host applications
    match /hostApplications {
      allow list: if request.auth != null && request.auth.token.admin == true;
    }
    
    // Default deny all rule
    match /{document=**} {
      allow read, write: if false;
    }
  }
} 